<!DOCTYPE html><html lang="zh-CN"><head><script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script><meta charset="utf-8"><title>php原生socket之IO多路复用以及实现web服务器</title><meta name="keywords" content="php,php原生socket,socket,通讯,服务端与客户端通讯,linux,socket原理,数据互通,系列文章,websocket,多路复用,php实现http服务器"><meta name="description" content="本文介绍php原生socket之IO多路复用以及实现web服务器简单实现，系列文章：php原生socket从入门到实战websocket聊天室，实现网络进程之间的通信，几乎所有应用程序都是采用 socket，socket是应用层与 TCP/IP 协议族通信的中间抽象层，它是一组接口。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/style/main.css"><link rel="stylesheet" href="/style/gitalk.min.css"><link rel="stylesheet" href="/style/simple-lightbox.min.css"><link rel="alternate" href="/atom.xml" title="codeover" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="codeover" type="application/rss+xml"></head><body><div id="app" class="main"><div class="site-header-container"><div class="site-header"><div class="left"> <a href="https://www.codeover.cn"><img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px"></a><a href="https://www.codeover.cn"><h1 class="site-title">codeover</h1></a></div><div class="right"><i class="icon menu-switch icon-menu-outline"></i></div></div></div><div class="menu-container" style="height:0;opacity:0"><nav class="menu-list"> <a href="/" class="menu purple-link">首页</a> <a href="/tags/" class="menu purple-link">标签</a> <a href="/categories/" class="menu purple-link">分类</a> <a href="/archives/" class="menu purple-link">归档</a> <a href="/about/" class="menu purple-link">关于</a></nav></div><div class="content-container"><div class="post-detail"><h2 class="post-title">php原生socket之IO多路复用以及实现web服务器</h2><div class="post-info post-detail-info"><span><i class="icon icon-calendar-outline"></i> 2022-06-17</span><span><i class="icon icon-pricetags-outline"></i> <a href="/tags/php/">php ，</a> <a href="/tags/socket/">socket</a></span></div><div class="post-content-wrapper"><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇系列文章，文章列表：</p><ol><li><a href="https://www.codeover.cn/php-socket/">php原生socket实现客户端与服务端数据传输</a></li><li>php原生socket之IO多路复用以及实现web服务器</li><li><a href="https://www.codeover.cn/php-socket-websocket/">php原生socket实现websocket聊天室</a></li></ol><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p><a href="https://www.codeover.cn/php-socket/">前文</a> 通过原生 socket 实现了简单的服务端与客户端通信，但当有多个客户端连接时，服务端仅能处理第一个客户端的请求，而无法对后续客户端服务</p><p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.codeover.cn/img/image-20220615231853841.gif-imageFop"><img src="/images/loading.svg" data-src="https://cdn.codeover.cn/img/image-20220615231853841.gif-imageFop" alt="服务端未正确处理截图" lazyload=""></a></p><p>产生这种情况的原因是因为IO模型是阻塞的，同一时刻只能由一个客户端进行访问，解决此问题主要有两种解决方案：</p><ol><li>多进程，即在服务端启动多个进程监听</li><li>IO多路复用机制，简单来说实现了 N 个客户端使用一根网线同时访问</li></ol><p>同时多路复用又分为两个不同的模型，即 <code>select</code> 与 <code>epoll</code>，常见的软件中，<code>Apache</code> 使用了 <code>select</code> 模型，<code>nginx</code> 则使用 <code>epoll</code> 模型。在 php 中内置了 <code>select</code> 模型，对应的函数为 <code>socket_select</code>，多路复用是实现 http 服务器的基础</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>在前文中我们介绍了 php 原生 socket 内置了 <code>socket_select</code> 函数实现了 <code>select</code> 模型，其语法如下：</p><figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">socket_select</span>(</span><br><span class="line">    <span class="keyword">array</span> &amp;<span class="variable">$read</span>,</span><br><span class="line">    <span class="keyword">array</span> &amp;<span class="variable">$write</span>,</span><br><span class="line">    <span class="keyword">array</span> &amp;<span class="variable">$except</span>,</span><br><span class="line">    <span class="keyword">int</span> <span class="variable">$seconds</span> [,</span><br><span class="line">    <span class="keyword">int</span> <span class="variable">$microseconds</span> = <span class="number">0</span>]</span><br><span class="line">): <span class="keyword">int</span>|<span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><p><code>read</code></p><p>服务端监听的套接字资源，当他有变化（即收到新的消息或有客户端连接、断开）时，<code>socket_select</code> 函数才会返回（否则继续阻塞），同时修改该变量为当前发生事件（收到消息或有客户端连接、断开）的套接字资源列表，并继续向下执行。</p></li><li><p><code>write</code></p><p>监听是否有客户端写数据，传入 <code>null</code> 则代表不关心是否有写变化</p></li><li><p><code>except</code></p><p>套接字内要排除的元素，传入 <code>null</code> 是 「监听」 全部</p></li><li><p><code>seconds</code></p><p>秒和微秒一起构成超时参数。如果传入 <code>null</code> 则会阻塞，为 0 非阻塞，如果是 &gt;0 则为最大阻塞时间</p></li><li><p><code>microseconds</code></p></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们在 <a href="https://www.codeover.cn/php-socket/#%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C">上篇文章</a> 简单实现了 socket 服务端监听与客户端的连接，接下来我们在服务端监听代码的基础上通过多路复用优化代码：</p><figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="variable">$socket</span> = <span class="title function_ invoke__">socket_create</span>(AF_INET, SOCK_STREAM, SOL_TCP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 ip 被释放后立即可使用</span></span><br><span class="line"><span class="title function_ invoke__">socket_set_option</span>(<span class="variable">$socket</span>, SOL_SOCKET, SO_REUSEADDR, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定ip与端口</span></span><br><span class="line"><span class="title function_ invoke__">socket_bind</span>(<span class="variable">$socket</span>, <span class="number">0</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line"><span class="title function_ invoke__">socket_listen</span>(<span class="variable">$socket</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sockets</span>[] = <span class="variable">$socket</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="variable">$tmp_sockets</span> = <span class="variable">$sockets</span>;</span><br><span class="line">    <span class="title function_ invoke__">socket_select</span>(<span class="variable">$tmp_sockets</span>, <span class="variable">$write</span>, <span class="variable">$except</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$tmp_sockets</span> <span class="keyword">as</span> <span class="variable">$sock</span>) {</span><br><span class="line">        <span class="comment">// 如果当前套接字等于 socket_create 创建的套接字，说明是有新的连接或有新的断开连接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$sock</span> == <span class="variable">$socket</span>) {</span><br><span class="line">            <span class="variable">$conn_sock</span> = <span class="title function_ invoke__">socket_accept</span>(<span class="variable">$socket</span>);</span><br><span class="line">            <span class="variable">$sockets</span>[] = <span class="variable">$conn_sock</span>;</span><br><span class="line">            <span class="title function_ invoke__">socket_getpeername</span>(<span class="variable">$conn_sock</span>, <span class="variable">$ip</span>, <span class="variable">$port</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'请求ip: '</span> . <span class="variable">$ip</span> . <span class="string">'端口: '</span> . <span class="variable">$port</span> . PHP_EOL;</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 否则说明是之前连接的客户端发来消息</span></span><br><span class="line">            <span class="variable">$msg</span> = <span class="title function_ invoke__">socket_read</span>(<span class="variable">$sock</span>, <span class="number">10240</span>);</span><br><span class="line">            <span class="title function_ invoke__">socket_write</span>(<span class="variable">$sock</span>, <span class="title function_ invoke__">strtoupper</span>(<span class="variable">$msg</span>));</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$msg</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在本示例中 <code>socket_select</code> 函数会阻塞当前进程，当 <code>$tmp_sockets</code> 数组内的 socket 资源有新的客户端连接或断开或收到新消息时，会将 <code>$tmp_sockets</code> 数组修改为当前活跃的 socket 资源，随后通过遍历该数组处理业务逻辑</p><p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.codeover.cn/img/GIF2022-6-1523-25-48.gif-imageFop"><img src="/images/loading.svg" data-src="https://cdn.codeover.cn/img/GIF2022-6-1523-25-48.gif-imageFop" alt="优化结果截图" lazyload=""></a></p><h2 id="使用socket实现简易http服务器"><a href="#使用socket实现简易http服务器" class="headerlink" title="使用socket实现简易http服务器"></a>使用socket实现简易http服务器</h2><p>http 协议是在 socket 的基础上规定了指定的数据格式，所以我们只需在 <code>socket_write</code> 时按照格式发送数据，浏览器就可正常响应请求</p><figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="variable">$socket</span> = <span class="title function_ invoke__">socket_create</span>(AF_INET, SOCK_STREAM, SOL_TCP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 ip 被释放后立即可使用</span></span><br><span class="line"><span class="title function_ invoke__">socket_set_option</span>(<span class="variable">$socket</span>, SOL_SOCKET, SO_REUSEADDR, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定ip与端口</span></span><br><span class="line"><span class="title function_ invoke__">socket_bind</span>(<span class="variable">$socket</span>, <span class="number">0</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line"><span class="title function_ invoke__">socket_listen</span>(<span class="variable">$socket</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sockets</span>[] = <span class="variable">$socket</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="variable">$tmp_sockets</span> = <span class="variable">$sockets</span>;</span><br><span class="line">    <span class="title function_ invoke__">socket_select</span>(<span class="variable">$tmp_sockets</span>, <span class="variable">$write</span>, <span class="variable">$except</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$tmp_sockets</span> <span class="keyword">as</span> <span class="variable">$sock</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$sock</span> == <span class="variable">$socket</span>) {</span><br><span class="line">            <span class="variable">$conn_sock</span> = <span class="title function_ invoke__">socket_accept</span>(<span class="variable">$socket</span>);</span><br><span class="line">            <span class="variable">$sockets</span>[] = <span class="variable">$conn_sock</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="variable">$msg</span> = <span class="title function_ invoke__">socket_read</span>(<span class="variable">$sock</span>, <span class="number">10240</span>);</span><br><span class="line">            <span class="title function_ invoke__">var_dump</span>(<span class="variable">$msg</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$msg</span> == <span class="string">''</span>) <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="variable">$output</span> = <span class="string">'&lt;h1&gt;this is php worker&lt;/h1&gt;'</span>;</span><br><span class="line">            <span class="variable">$len</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$output</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="variable">$response</span> = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line">            <span class="variable">$response</span> .= <span class="string">"content-type: text/html\r\n"</span>;</span><br><span class="line">            <span class="variable">$response</span> .= <span class="string">"server: php socket\r\n"</span>;</span><br><span class="line">            <span class="variable">$response</span> .= <span class="string">"Content-Length: <span class="subst">{$len}</span>\r\n\r\n"</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="variable">$response</span> .= <span class="variable">$output</span>;</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">socket_write</span>(<span class="variable">$sock</span>, <span class="variable">$response</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在服务端运行此示例，随后在浏览器访问 <code>ip:8888</code> ，可以看到如下：</p> <a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.codeover.cn/img/image-20220616235259254.png-imageFop"><img src="/images/loading.svg" data-src="https://cdn.codeover.cn/img/image-20220616235259254.png-imageFop" alt="浏览器访问截图" style="zoom:50%" lazyload=""></a><p>同时服务端会输出如下内容：</p><figure class="highlight http"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>124.222.**.**:8888</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>jenkins-timestamper-offset=-28800000; _ga=GA1.1.1403944751.1652010033; _ga_2GM6102E19=GS1.1.1652802985.7.1.1652803014.0</span><br></pre></td></tr></tbody></table></figure><p>该内容即为用户端请求原始数据，可解析此数据并根据请求做出响应，比如使用 <code>file_get_content</code> 读取指定文件内容返回给浏览器</p></div><div class="top-div"><ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%89%8D%E8%A8%80"><span class="top-box-text">前言</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="top-box-text">多路复用</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%AF%AD%E6%B3%95"><span class="top-box-text">语法</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BC%98%E5%8C%96"><span class="top-box-text">优化</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%BD%BF%E7%94%A8socket%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93http%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="top-box-text">使用socket实现简易http服务器</span></a></li></ol></div></div></div><div class="next-post"><a class="purple-link" href="/php-socket/"><h3 class="post-title"> 下一篇：php原生socket实现客户端与服务端数据传输</h3></a></div></div><div id="gitalk-container"></div><footer><div class="site-footer"><div class="social-container"><a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank"><i class="icon icon-github"></i></a></div> Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a> | <a href="https://beian.miit.gov.cn" target="_blank">豫ICP备2022011962号</a> | <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41010402002848" target="_blank">豫公网安备41010402002848号</a></div></footer></div><script id="hexo-configurations">window.theme_config={image:{lazyload_enable:!0,photo_zoom:"simple-lightbox"}},window.is_post=!0</script><script src="/js/main.js"></script><script src="/js/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"eaa8ec37487184406145",clientSecret:"77f9955d0267c1331df7cc706cfa385d2befb9c6",repo:"blog",owner:"f-dong",admin:["f-dong"],id:location.pathname.slice(1,location.pathname.lastIndexOf("/")).substring(0,49),distractionFreeMode:!1,createIssueManually:!0});gitalk.render("gitalk-container")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-2GM6102E19"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2GM6102E19")</script><script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){new SimpleLightbox(".post-detail .simple-lightbox",{fileExt:!1,captionsData:"alt"})})</script></body></html>