<!DOCTYPE html><html lang="zh-CN"><head><script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script><meta charset="utf-8"><title>Go 语言中的 RSA 加密、解密、签名与验签</title><meta name="keywords" content="golang,Go语言,RSA,加密,解密,验签,签名,非对称加密,密码学,证书生成,RSA私钥生成,php,php rsa"><meta name="description" content="RSA 加密演算法是一种非对称加密演算法，在一些项目中经常使用，在 golang 中 RSA 的加密、解密、签名与验签主要使用 crypto/x509 和 crypto/rsa 两个包中的方法。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/style/main.css"><link rel="stylesheet" href="/style/gitalk.min.css"><link rel="alternate" href="/atom.xml" title="codeover" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="codeover" type="application/rss+xml"></head><body><div id="app" class="main"><div class="site-header-container"><div class="site-header"><div class="left"> <a href="https://www.codeover.cn"><img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px"></a><a href="https://www.codeover.cn"><h1 class="site-title">codeover</h1></a></div><div class="right"><i class="icon menu-switch icon-menu-outline"></i></div></div></div><div class="menu-container" style="height:0;opacity:0"><nav class="menu-list"> <a href="/" class="menu purple-link">首页</a> <a href="/tags/" class="menu purple-link">标签</a> <a href="/categories/" class="menu purple-link">分类</a> <a href="/archives/" class="menu purple-link">归档</a> <a href="/about/" class="menu purple-link">关于</a></nav></div><div class="content-container"><div class="post-detail"><h2 class="post-title">Go 语言中的 RSA 加密、解密、签名与验签</h2><div class="post-info post-detail-info"><span><i class="icon icon-calendar-outline"></i> 2023-02-21</span><span><i class="icon icon-pricetags-outline"></i> <a href="/tags/Go/">Go</a></span></div><div class="post-content-wrapper"><div class="post-content"><p>RSA 加密演算法是一种非对称加密演算法<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="footnote--top">[1]<content class="footnote--pop-ups">非对称式密码学（英语：Asymmetric cryptography）也称公开密钥密码学（英语：Public-key cryptography），是密码学的一种演算法，他需要两个密钥，分别是公钥与私钥。公钥用作加密，私钥则用作解密。</content></span></a></sup>，在一些项目中经常使用，是目前使用最广的数据安全加密算法之一。在 golang 中， RSA 的加密、解密、签名与验签主要使用 <code>crypto/x509</code> 和 <code>crypto/rsa</code> 两个包中的方法。</p><h2 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h2><p>RSA 是通过生成一个公钥和与之对应的私钥来进行加/解密的，公钥与私钥一一对应，公钥可以用来加密数据，但不能用于解密，私钥可以解密由它所对应的公钥加密的数据。我们可以将公钥分发，之后所有持有公钥的人都可以使用公钥对信息进行加密，唯一能获取信息的方式就是用我们自己的私钥来进行解密。</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>代码示例:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// RsaEncryptBase64 使用 RSA 公钥加密数据, 返回加密后并编码为 base64 的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaEncryptBase64</span><span class="params">(originalData, publicKey <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">	block, _ := pem.Decode([]<span class="type">byte</span>(publicKey))</span><br><span class="line">	pubKey, parseErr := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> parseErr != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(parseErr)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"解析公钥失败"</span>)</span><br><span class="line">	}</span><br><span class="line">	encryptedData, err := rsa.EncryptPKCS1v15(rand.Reader, pubKey.(*rsa.PublicKey), []<span class="type">byte</span>(originalData))</span><br><span class="line">	<span class="keyword">return</span> base64.StdEncoding.EncodeToString(encryptedData), err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解析:</p><ul><li><code>originalData</code>，加密的原数据。</li><li><code>publicKey</code>，RSA 公钥。</li></ul><blockquote><p>注: RSA 加密时，对密文长度有限制，超出长度限制则需要分段处理（把数据分割为多段分别加密与解密）不过 RSA 大部分的用途中不会加密过长数据。具体的长度限制为 <code>密钥长度除8减11个字节</code>，例如 1024 位的 RSA 密钥对最长加密数据长度为 <code>1024/8-11=117 Byte</code>，即使用 1024 位的 RSA 公钥加密数据时，明文数据最大为 117 Byte。</p></blockquote><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>代码示例:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// RsaDecryptBase64 使用 RSA 私钥解密数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaDecryptBase64</span><span class="params">(encryptedData, privateKey <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">	encryptedDecodeBytes, err := base64.StdEncoding.DecodeString(encryptedData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	}</span><br><span class="line">	block, _ := pem.Decode([]<span class="type">byte</span>(privateKey))</span><br><span class="line">	priKey, parseErr := x509.ParsePKCS8PrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> parseErr != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(parseErr)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"解析私钥失败"</span>)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	originalData, encryptErr := rsa.DecryptPKCS1v15(rand.Reader, priKey.(*rsa.PrivateKey), encryptedDecodeBytes)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(originalData), encryptErr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解析:</p><ul><li><code>originalData</code>，Base64 格式的密文内容。</li><li><code>privateKey</code>，RSA 私钥。</li><li><code>返回值1</code> 解密后的明文数据。</li></ul><blockquote><p>注: RSA 解密时对内容有同样的长度限制，见前文说明。</p></blockquote><h2 id="签名与验签"><a href="#签名与验签" class="headerlink" title="签名与验签"></a>签名与验签</h2><p>RSA 密钥对也可用于签名和验签，不同于加密，签名不能保护内容的机密性，其目的为验证消息的真实性，消息接收者通过验证签名来判断消息是否被篡改过。只有拥有私钥的人才能对信息签名，拥有公钥的人可以验证签名正确性。</p><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// originalData 签名前的原始数据</span></span><br><span class="line"><span class="comment">// privateKey RSA 私钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">signBase64</span><span class="params">(originalData, privateKey <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">	block, _ := pem.Decode([]<span class="type">byte</span>(privateKey))</span><br><span class="line">	priKey, parseErr := x509.ParsePKCS8PrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> parseErr != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(parseErr)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"解析私钥失败"</span>)</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sha256 加密方式，必须与 下面的 crypto.SHA256 对应</span></span><br><span class="line">    <span class="comment">// 例如使用 sha1 加密，此处应是 sha1.New()，对应 crypto.SHA1</span></span><br><span class="line">	hash := sha256.New()</span><br><span class="line">	hash.Write([]<span class="type">byte</span>(originalData))</span><br><span class="line">	signature, err := rsa.SignPSS(rand.Reader, priKey.(*rsa.PrivateKey), crypto.SHA256, hash.Sum(<span class="literal">nil</span>), <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> base64.StdEncoding.EncodeToString(signature), err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="验签"><a href="#验签" class="headerlink" title="验签"></a>验签</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// originalData 签名前的原始数据</span></span><br><span class="line"><span class="comment">// signData Base64 格式的签名串</span></span><br><span class="line"><span class="comment">// pubKey 公钥（需与加密时使用的私钥相对应）</span></span><br><span class="line"><span class="comment">// 返回 true 代表验签通过，反之为不通过</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerySignWithBase64</span><span class="params">(originalData, signData, pubKey <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) {</span><br><span class="line">	sign, err := base64.StdEncoding.DecodeString(signData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	block, _ := pem.Decode([]<span class="type">byte</span>(pubKey))</span><br><span class="line">	pub, err1 := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err1</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">// sha256 加密方式，必须与 下面的 crypto.SHA256 对应</span></span><br><span class="line">    <span class="comment">// 例如使用 sha1 加密，此处应是 sha1.New()，对应 crypto.SHA1</span></span><br><span class="line">	hash := sha256.New()</span><br><span class="line">	hash.Write([]<span class="type">byte</span>(originalData))</span><br><span class="line">	verifyErr := rsa.VerifyPKCS1v15(pub.(*rsa.PublicKey), crypto.SHA256, hash.Sum(<span class="literal">nil</span>), sign)</span><br><span class="line">	<span class="keyword">return</span> verifyErr == <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="附1：公私钥的生成"><a href="#附1：公私钥的生成" class="headerlink" title="附1：公私钥的生成"></a>附1：公私钥的生成</h2><p>使用 GO 生成 RSA 公私钥较为简单，需要注意的是：私钥要严格保密，谨防外泄。生成公私钥代码如下:</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// bits 生成的公私钥对的位数，一般为 1024 或 2048</span></span><br><span class="line"><span class="comment">// privateKey 生成的私钥</span></span><br><span class="line"><span class="comment">// publicKey 生成的公钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenRsaKey</span><span class="params">(bits <span class="type">int</span>)</span></span> (privateKey, publicKey <span class="type">string</span>) {</span><br><span class="line">	priKey, err2 := rsa.GenerateKey(rand.Reader, bits)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> {</span><br><span class="line">		<span class="built_in">panic</span>(err2)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	derStream := x509.MarshalPKCS1PrivateKey(priKey)</span><br><span class="line">	block := &amp;pem.Block{</span><br><span class="line">		Type:  <span class="string">"PRIVATE KEY"</span>,</span><br><span class="line">		Bytes: derStream,</span><br><span class="line">	}</span><br><span class="line">	prvKey := pem.EncodeToMemory(block)</span><br><span class="line">	puKey := &amp;priKey.PublicKey</span><br><span class="line">	derPkix, err := x509.MarshalPKIXPublicKey(puKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	}</span><br><span class="line">	block = &amp;pem.Block{</span><br><span class="line">		Type:  <span class="string">"PUBLIC KEY"</span>,</span><br><span class="line">		Bytes: derPkix,</span><br><span class="line">	}</span><br><span class="line">	pubKey := pem.EncodeToMemory(block)</span><br><span class="line"></span><br><span class="line">	privateKey = <span class="type">string</span>(prvKey)</span><br><span class="line">	publicKey = <span class="type">string</span>(pubKey)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="附2-PHP-中对应用法"><a href="#附2-PHP-中对应用法" class="headerlink" title="附2: PHP 中对应用法"></a>附2: PHP 中对应用法</h2><h3 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h3><figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA 加密</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $data 待加密数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $publicKey 公钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string base64编码后的加密数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rsaEncryptBase64</span>(<span class="params"><span class="variable">$data</span>, <span class="variable">$publicKey</span></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="variable">$publicKey</span> = <span class="title function_ invoke__">openssl_get_publickey</span>(<span class="variable">$publicKey</span>);</span><br><span class="line">    <span class="title function_ invoke__">openssl_public_encrypt</span>(<span class="variable">$data</span>, <span class="variable">$encrypt</span>, <span class="variable">$publicKey</span>);</span><br><span class="line">    <span class="title function_ invoke__">openssl_free_key</span>(<span class="variable">$publicKey</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$encrypt</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h3><figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA 解密</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $data base64编码的密文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $privateKey 私钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string 解密后的明文内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rsaEncryptBase64</span>(<span class="params"><span class="variable">$data</span>, <span class="variable">$privateKey</span></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="variable">$privateKey</span> = <span class="title function_ invoke__">openssl_get_privatekey</span>(<span class="variable">$privateKey</span>);</span><br><span class="line">    <span class="title function_ invoke__">openssl_private_decrypt</span>(<span class="variable">$data</span>, <span class="variable">$encrypt</span>, <span class="variable">$privateKey</span>);</span><br><span class="line">    <span class="title function_ invoke__">openssl_free_key</span>(<span class="variable">$privateKey</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$encrypt</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="签名-1"><a href="#签名-1" class="headerlink" title="签名"></a>签名</h3><figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $original_data 签名前的原始数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $private_key 私钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string 签名后的 base64 字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">verySignWithBase64</span>(<span class="params"><span class="variable">$original_data</span>, <span class="variable">$private_key</span></span>) </span>{</span><br><span class="line">    <span class="variable">$openssl_res</span> = <span class="title function_ invoke__">openssl_get_privatekey</span>(<span class="variable">$private_key</span>);</span><br><span class="line">    <span class="title function_ invoke__">openssl_sign</span>(<span class="variable">$original_data</span>, <span class="variable">$signature</span>, <span class="variable">$openssl_res</span>, OPENSSL_ALGO_SHA256);</span><br><span class="line">    <span class="title function_ invoke__">openssl_free_key</span>(<span class="variable">$openssl_res</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$signature</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="验签-1"><a href="#验签-1" class="headerlink" title="验签"></a>验签</h3><figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $original_data 签名前的原始数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $signature Base64 格式的签名串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $public_key 公钥（需与加密时使用的私钥相对应）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool 返回 true 代表验签通过，反之为不通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">verySignWithBase64</span>(<span class="params"><span class="variable">$original_data</span>, <span class="variable">$signature</span>, <span class="variable">$public_key</span></span>) </span>{</span><br><span class="line">    <span class="variable">$openssl_res</span> = <span class="title function_ invoke__">openssl_get_publickey</span>(<span class="variable">$public_key</span>);</span><br><span class="line">    <span class="variable">$verify_res</span> = <span class="title function_ invoke__">openssl_verify</span>(<span class="variable">$original_data</span>, <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$signature</span>), <span class="variable">$openssl_res</span>, OPENSSL_ALGO_SHA256);</span><br><span class="line">    <span class="title function_ invoke__">openssl_free_key</span>(<span class="variable">$openssl_res</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> == <span class="variable">$verify_res</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0;margin-left:40px"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px;margin-left:-40px">1.</span><span style="display:inline-block;vertical-align:top;margin-left:10px">非对称式密码学（英语：Asymmetric cryptography）也称公开密钥密码学（英语：Public-key cryptography），是密码学的一种演算法，他需要两个密钥，分别是公钥与私钥。公钥用作加密，私钥则用作解密。 <a href="#fnref:1">↩</a></span></li></ol></div></div></div><div class="top-div"><ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86"><span class="top-box-text">加密与解密</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8A%A0%E5%AF%86"><span class="top-box-text">加密</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%A7%A3%E5%AF%86"><span class="top-box-text">解密</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%AD%BE%E5%90%8D%E4%B8%8E%E9%AA%8C%E7%AD%BE"><span class="top-box-text">签名与验签</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%AD%BE%E5%90%8D"><span class="top-box-text">签名</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%AA%8C%E7%AD%BE"><span class="top-box-text">验签</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%99%841%EF%BC%9A%E5%85%AC%E7%A7%81%E9%92%A5%E7%9A%84%E7%94%9F%E6%88%90"><span class="top-box-text">附1：公私钥的生成</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%99%842-PHP-%E4%B8%AD%E5%AF%B9%E5%BA%94%E7%94%A8%E6%B3%95"><span class="top-box-text">附2: PHP 中对应用法</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8A%A0%E5%AF%86-1"><span class="top-box-text">加密</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%A7%A3%E5%AF%86-1"><span class="top-box-text">解密</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%AD%BE%E5%90%8D-1"><span class="top-box-text">签名</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E9%AA%8C%E7%AD%BE-1"><span class="top-box-text">验签</span></a></li></ol></li></ol></div></div></div><div class="next-post"><a class="purple-link" href="/hexo-footnotes/"><h3 class="post-title"> 下一篇：Hexo 主题里的脚注功能</h3></a></div></div><div id="gitalk-container"></div><footer><div class="site-footer"><div class="social-container"><a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank"><i class="icon icon-github"></i></a></div> Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a> | <a href="https://beian.miit.gov.cn" target="_blank">豫ICP备2022011962号</a> | <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41010402002848" target="_blank">豫公网安备41010402002848号</a></div></footer></div><script id="hexo-configurations">window.theme_config={image:{lazyload_enable:!0,photo_zoom:"simple-lightbox"}},window.is_post=!0</script><script src="/js/main.js"></script><script src="/js/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"eaa8ec37487184406145",clientSecret:"77f9955d0267c1331df7cc706cfa385d2befb9c6",repo:"blog",owner:"f-dong",admin:["f-dong"],id:location.pathname.slice(1,location.pathname.lastIndexOf("/")).substring(0,49),distractionFreeMode:!1,createIssueManually:!0});gitalk.render("gitalk-container")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-2GM6102E19"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2GM6102E19")</script></body></html>