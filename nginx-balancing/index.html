<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>Nginx 负载均衡配置</title><meta name="keywords" content="Nginx,Nginx 负载均衡配置,linux,服务器搭建,反向代理,负载均衡"><meta name="description" content="服务器压力过大时，我们会引入负载均衡，以便将请求压力分散于各个服务器，已提供服务稳定性，本文介绍nginx如何配置负载均衡，以及负载均衡常见的算法。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/style/main.css"><link rel="stylesheet" href="/style/fontawesome.css"><link rel="stylesheet" href="/style/jquery.fancybox.min.css"><link rel="stylesheet" href="/style/gitalk.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-2GM6102E19"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2GM6102E19")</script><link rel="alternate" href="/atom.xml" title="codeover" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="codeover" type="application/rss+xml"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><div id="app" class="main"><div class="site-header-container"><div class="site-header"><div class="left"> <a href="https://www.codeover.cn"><img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px"></a><a href="https://www.codeover.cn"><h1 class="site-title">codeover</h1></a></div><div class="right"><i class="icon menu-switch icon-menu-outline"></i></div></div></div><div class="menu-container" style="height:0;opacity:0"><nav class="menu-list"> <a href="/" class="menu purple-link">首页</a> <a href="/tags/" class="menu purple-link">标签</a> <a href="/categories/" class="menu purple-link">分类</a> <a href="/archives/" class="menu purple-link">归档</a> <a href="/about/" class="menu purple-link">关于</a></nav></div><div class="content-container"><div class="post-detail"><h2 class="post-title">Nginx 负载均衡配置</h2><div class="post-info post-detail-info"><span><i class="icon-calendar-outline"></i> 2022-05-03</span><span><i class="icon-pricetags-outline"></i> <a href="/tags/linux/">linux ，</a> <a href="/tags/Nginx/">Nginx</a></span></div><div class="post-content-wrapper"><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在现实的应用场景中，一台后端服务器出现单点故障的概率很大或者单台机器的吞吐量有限，无法承担过多请求，这时候就需要在 nginx 后端配置多台服务器，利用 nginx 内置的规则将请求转发至不同的后端机器上。</p><h2 id="负载均衡常用算法"><a href="#负载均衡常用算法" class="headerlink" title="负载均衡常用算法"></a>负载均衡常用算法</h2><h3 id="1-轮询"><a href="#1-轮询" class="headerlink" title="1. 轮询"></a>1. 轮询</h3><p>轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。该算法会遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。</p><p>特点：由于在该算法中每个请求按请求时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的情况下使用，其中每个服务器承载了相同的负载。但对于服务器性能不同的服务器而言，该算法会引发资源分配不合理等问题。</p><p>用法：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="section">http</span> {</span><br><span class="line">    <span class="section">upstream</span> testServer { <span class="comment"># 定义负载服务器列表</span></span><br><span class="line">      <span class="attribute">server</span> ip:port; <span class="comment"># ip 为负载服务器 port 为端口 缺省为80</span></span><br><span class="line">      <span class="attribute">server</span> ip:port;</span><br><span class="line">      <span class="attribute">server</span> ip:port;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> {</span><br><span class="line">        ...</span><br><span class="line">        <span class="section">location</span> / {</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://testServer; <span class="comment"># testServer 为上方定义的服务器集群</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-加权轮询"><a href="#2-加权轮询" class="headerlink" title="2. 加权轮询"></a>2. 加权轮询</h3><p>为了避免轮询带来的弊端，加权轮询应运而生。在每个服务器后添加 <code>weight</code> 即为加权轮询，一般情况下，<code>weight</code> 的值越大分配到的请求就越多，对应的性能也更好。</p><p>特点：加权轮询可以应用于服务器性能不等的集群中，使资源分配更加的合理化。</p><p>用法：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="section">http</span> {</span><br><span class="line">    <span class="section">upstream</span> testServer {</span><br><span class="line">      <span class="attribute">server</span> ip:port weight=<span class="number">2</span>; <span class="comment"># weight 为对应的权重 权重越高分配到的请求越多</span></span><br><span class="line">      <span class="attribute">server</span> ip:port weight=<span class="number">8</span>;</span><br><span class="line">      <span class="attribute">server</span> ip:port weight=<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> {</span><br><span class="line">        ...</span><br><span class="line">        <span class="section">location</span> / {</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://testServer; <span class="comment"># testServer 为上方定义的服务器集群</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-IP-哈希（IP-hash）"><a href="#3-IP-哈希（IP-hash）" class="headerlink" title="3. IP 哈希（IP hash）"></a>3. IP 哈希（IP hash）</h3><p><code>ip_hash</code> 根据发出请求的 IP 的 <code>hash</code> 值来分配对应服务器，该方式可使同 IP 发出的请求转发到同一服务器，或具有相同 <code>hash</code> 值的不同 IP 转发到同一个服务器。</p><p>特点：该算法可在一定程度上保证同一用户分配到的是同一服务器，并在一定程度上可解决集群部署环境下 Session 不共享的问题</p><p>用法：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="section">http</span> {</span><br><span class="line">    <span class="section">upstream</span> testServer {</span><br><span class="line">      ip_hash; <span class="comment"># 定义使用 ip_hash 算法</span></span><br><span class="line">      <span class="attribute">server</span> ip:port weight=<span class="number">2</span>; <span class="comment"># weight 为对应的权重 权重越高分配到的请求越多</span></span><br><span class="line">      <span class="attribute">server</span> ip:port weight=<span class="number">8</span>;</span><br><span class="line">      <span class="attribute">server</span> ip:port weight=<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> {</span><br><span class="line">        ...</span><br><span class="line">        <span class="section">location</span> / {</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://testServer; <span class="comment"># testServer 为上方定义的服务器集群</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-URL-哈希（URL-hash）"><a href="#4-URL-哈希（URL-hash）" class="headerlink" title="4. URL 哈希（URL hash）"></a>4. URL 哈希（URL hash）</h3><p><code>url_hash</code> 是根据请求的 URL 的 hash 值来分配服务器。该算法的特点是，相同 URL 的请求会分配给固定的服务器，当存在缓存的时候，效率一般较高。然而 Nginx 默认不支持这种负载均衡算法，需要依赖第三方库。</p><h3 id="5-最小连接数（Least-Connections）"><a href="#5-最小连接数（Least-Connections）" class="headerlink" title="5. 最小连接数（Least Connections）"></a>5. 最小连接数（Least Connections）</h3><p>假设共有 N 台服务器，当有新的请求出现时，遍历服务器节点列表并选取其中连接数最小的一台服务器来响应当前请求。连接数可以理解为当前正在处理的请求数量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Nginx 作为一款优秀的反向代理服务器，可以通过不同的负载均衡算法来解决请求量过大情况下的服务器资源分配问题。较为常见的负载均衡算法有轮询、加权轮询、IP 哈希等等，可分别应对不同的请求场景。</p></div><div class="top-div"><ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="top-box-text">负载均衡常用算法</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#1-%E8%BD%AE%E8%AF%A2"><span class="top-box-text">1. 轮询</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2"><span class="top-box-text">2. 加权轮询</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-IP-%E5%93%88%E5%B8%8C%EF%BC%88IP-hash%EF%BC%89"><span class="top-box-text">3. IP 哈希（IP hash）</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-URL-%E5%93%88%E5%B8%8C%EF%BC%88URL-hash%EF%BC%89"><span class="top-box-text">4. URL 哈希（URL hash）</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#5-%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%EF%BC%88Least-Connections%EF%BC%89"><span class="top-box-text">5. 最小连接数（Least Connections）</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%80%BB%E7%BB%93"><span class="top-box-text">总结</span></a></li></ol></div></div></div><div class="next-post"><a class="purple-link" href="/nginx-gzip/"><h3 class="post-title"> 下一篇：nginx 使用 gzip 压缩静态资源</h3></a></div></div><div id="gitalk-container"></div><footer><div class="site-footer"><div class="social-container"><a href="https://github.com/f-dong" target="_blank"><i class="fab fa-github"></i></a></div> Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a> | <a class="icp" href="https://beian.miit.gov.cn" target="_blank">豫ICP备2022011962号</a> | <a class="icp" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41010402002848" target="_blank">豫公网安备41010402002848号</a></div></footer></div><script src="/js/jquery.min.js"></script><script src="/js/jquery.fancybox.min.js"></script><script src="/js/main.js"></script><script src="/js/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"eaa8ec37487184406145",clientSecret:"77f9955d0267c1331df7cc706cfa385d2befb9c6",repo:"blog",owner:"f-dong",admin:["f-dong"],id:location.pathname.slice(1,location.pathname.lastIndexOf("/")).substring(0,49),distractionFreeMode:!1,createIssueManually:!0});gitalk.render("gitalk-container")</script></body></html>