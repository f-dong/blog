<!DOCTYPE html><html><head><meta charset="utf-8"><title>php原生socket实现客户端与服务端数据传输</title><meta name="keywords" content="php,php原生socket,socket,通讯,服务端与客户端通讯,linux,socket原理,数据互通,系列文章,websocket"><meta name="description" content="本文介绍socket的原理与使用php原生方式的简单实现，系列文章：php原生socket从入门到实战websocket聊天室，实现网络进程之间的通信，几乎所有应用程序都是采用 socket，socket是应用层与 TCP/IP 协议族通信的中间抽象层，它是一组接口。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/style/main.css"><link rel="stylesheet" href="/style/fontawesome.css"><link rel="stylesheet" href="/style/jquery.fancybox.min.css"><link rel="stylesheet" href="/style/gitalk.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-2GM6102E19"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2GM6102E19")</script><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="codeover" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="codeover" type="application/rss+xml"></head><body><div id="app" class="main"><div class="site-header-container"><div class="site-header"><div class="left"> <a href="https://www.codeover.cn"><img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px"></a><a href="https://www.codeover.cn"><h1 class="site-title">codeover</h1></a></div><div class="right"><i class="icon menu-switch icon-menu-outline"></i></div></div></div><div class="menu-container" style="height:0;opacity:0"><nav class="menu-list"> <a href="/" class="menu purple-link">首页</a> <a href="/tags/" class="menu purple-link">标签</a> <a href="/categories/" class="menu purple-link">分类</a> <a href="/archives/" class="menu purple-link">归档</a> <a href="/about/" class="menu purple-link">关于</a></nav></div><div class="content-container"><div class="post-detail"><h2 class="post-title">php原生socket实现客户端与服务端数据传输</h2><div class="post-info post-detail-info"><span><i class="icon-calendar-outline"></i> 2022-06-14</span><span><i class="icon-pricetags-outline"></i> <a href="/tags/php/">php ，</a> <a href="/tags/socket/">socket</a></span></div><div class="post-content-wrapper"><div class="post-content"><h2 id="socket介绍"><a href="#socket介绍" class="headerlink" title="socket介绍"></a>socket介绍</h2><p>实现网络进程之间的通信，几乎所有应用程序都是采用 socket，socket是应用层与 TCP/IP 协议族通信的中间抽象层，它是一组接口。在设计模式中，socket其实是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 socket 接口后面，对用户来说，一局简单的接口就是全部，让 socket 去阻止数据，以符合指定的协议</p><p><img src="https://cdn.codeover.cn/img/socket_flow_chart.jpg-imageFop" alt="socket流程图"></p><p>socket 的英文原意是 「孔」或「插座」，通常也被称作「套接字」，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。</p><p>socket 链接的三个过程</p><ol><li>服务端监听：IP+端口号</li><li>客户端请求：发出向服务端的 IP 以及端口的连接请求</li><li>链接确认：服务端套接字监听到或者说接收到客户端套接字连接请求，他就会建立一个新的进程，把服务端的套接字描述发给客户端，以响应客户端的请求，一旦客户端确认了此描述，连接就建立好了。儿服务端的套接字继续处于监听状态，继续接受其他客户端套接字的连接请求。</li></ol><p><img src="https://cdn.codeover.cn/img/image-20220613231853841.png-imageFop" alt="建立连接过程"></p><h2 id="php实现socket"><a href="#php实现socket" class="headerlink" title="php实现socket"></a>php实现socket</h2><p>如果需要在 php 中使用 socket，则需要在编译 php 是添加 <code>--enable-sockets</code> 配置项来启用，可使用 <code>php -m|grep sockets</code> 命令检查启用情况，具体编译过程可参考 <a href="https://www.codeover.cn/centos-install-php/">这篇文章</a></p><h3 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h3><p>服务端与客户端简略代码如下，运行后服务端会阻塞等待客户端连接，客户端会在控制台要求输入内容，输入后信息会在服务端打印，同时客户端显示转为大写的内容，此示例服务端与客户端运行在一台服务器：</p><h4 id="服务端监听"><a href="#服务端监听" class="headerlink" title="服务端监听"></a>服务端监听</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="variable">$socket</span> = <span class="title function_ invoke__">socket_create</span>(AF_INET, SOCK_STREAM, SOL_TCP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 ip 被释放后立即可使用</span></span><br><span class="line"><span class="title function_ invoke__">socket_set_option</span>(<span class="variable">$socket</span>, SOL_SOCKET, SO_REUSEADDR, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定ip与端口</span></span><br><span class="line"><span class="title function_ invoke__">socket_bind</span>(<span class="variable">$socket</span>, <span class="number">0</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line"><span class="title function_ invoke__">socket_listen</span>(<span class="variable">$socket</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="comment">// 接收内容</span></span><br><span class="line">    <span class="variable">$conn_sock</span> = <span class="title function_ invoke__">socket_accept</span>(<span class="variable">$socket</span>);</span><br><span class="line">    <span class="title function_ invoke__">socket_getpeername</span>(<span class="variable">$conn_sock</span>, <span class="variable">$ip</span>, <span class="variable">$port</span>);</span><br><span class="line">    <span class="comment">// echo '请求ip: ' . $ip . PHP_EOL . '端口: ' . $port;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 获取消息内容</span></span><br><span class="line">        <span class="variable">$msg</span> = <span class="title function_ invoke__">socket_read</span>(<span class="variable">$conn_sock</span>, <span class="number">10240</span>);</span><br><span class="line">        <span class="comment">// TODO 处理业务逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将信息转为大写并原样返回客户端</span></span><br><span class="line">        <span class="title function_ invoke__">socket_write</span>(<span class="variable">$conn_sock</span>, <span class="title function_ invoke__">strtoupper</span>(<span class="variable">$msg</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$msg</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="variable">$socket</span> = <span class="title function_ invoke__">socket_create</span>(AF_INET, SOCK_STREAM, SOL_TCP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务端</span></span><br><span class="line"><span class="title function_ invoke__">socket_connect</span>(<span class="variable">$socket</span>, <span class="string">'127.0.0.1'</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="comment">// 让控制台输入内容</span></span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(STDOUT, <span class="string">'请输入内容：'</span>);</span><br><span class="line">    <span class="variable">$in</span> = <span class="title function_ invoke__">fgets</span>(STDIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务端发送内容</span></span><br><span class="line">    <span class="title function_ invoke__">socket_write</span>(<span class="variable">$socket</span>, <span class="variable">$in</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取服务端发送的消息</span></span><br><span class="line">    <span class="variable">$msg</span> = <span class="title function_ invoke__">socket_read</span>(<span class="variable">$socket</span>, <span class="number">10240</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$msg</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="语法解释"><a href="#语法解释" class="headerlink" title="语法解释"></a>语法解释</h3><h4 id="socket-create"><a href="#socket-create" class="headerlink" title="socket_create"></a>socket_create</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">socket_create</span>(<span class="keyword">int</span> <span class="variable">$domain</span>,<span class="keyword">int</span> <span class="variable">$type</span>, <span class="keyword">int</span> <span class="variable">$protocol</span>): resource|<span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>创建并返回一个套接字资源，通常也称作一个通讯节点。一个典型的 socket 由至少 2 个套接字组成，其中一个运行在客户端，一个运行在服务端。</p><p>参数：</p><ul><li><p><code>domain</code> 指定当前套接字使用什么协议，可用协议如下：</p><table><thead><tr><th>Domain</th><th>描述</th></tr></thead><tbody><tr><td>AF_INET</td><td>IPv4 网络协议，TCP 与 UDP 都可使用此协议</td></tr><tr><td>AF_INET6</td><td>IPv6 网络协议，TCP 与 UDP 都可使用此协议</td></tr><tr><td>AF_UNIX</td><td>本地通讯协议，具有高性能与低成本的 IPC</td></tr></tbody></table></li><li><p><code>type</code> 用户指定当前套接字使用的类型</p><table><thead><tr><th>type</th><th>描述</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>可顺序化的、可靠的、全双工的、基于链接的字节流，支持数据传送流量控制机制。TCP 协议基于这种流式套接字。</td></tr><tr><td>SOCK_DGRAM</td><td>数据报文的支持（无连接、不可靠、固定最大长度）UDP 协议基于这种报文套接字</td></tr><tr><td>SOCK_SEQPACKET</td><td>可顺序化的、可靠的、全双工的、面向连接的、固定最大长度的数据通信，数据端通过接收每一个数据段来读取整个数据包</td></tr><tr><td>SOCK_RAW</td><td>读取原始的网络协议，这种特殊的套接字可用于手工构建任意类型的协议，一般使用这个套接字来实现 ICMP 请求</td></tr><tr><td>SOCK_RDM</td><td>可靠的数据层，但不保证到达顺序，一般的操作系统都未实现此功能</td></tr></tbody></table></li><li><p><code>protocol</code> 设置指定 domain 套接字下的具体协议，如果所需协议是 TCP 或者 UDP，可以直接使用常量 <code>SOL_TCP</code> 或 <code>SOL_UDP</code>，这个参数的具体值可通过 <code>getprotobyname()</code> 函数获取</p></li></ul><p>返回值</p><p><code>socket_create()</code> 正确时返回一个套接字资源，失败时返回 <code>false</code>。可以调用 <code>socket_last_error()</code> 获取错误码，错误码可以通过 <code>socket_strerror(int $err_no)</code> 转换为文字的错误说明。</p><h4 id="socket-bind"><a href="#socket-bind" class="headerlink" title="socket_bind"></a>socket_bind</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">socket_bind</span>(resource <span class="variable">$socket</span>, <span class="keyword">string</span> <span class="variable">$address</span> [, <span class="keyword">int</span> <span class="variable">$port</span>]): <span class="keyword">bool</span></span><br></pre></td></tr></tbody></table></figure><p>绑定一个地址与端口到套接字</p><p>参数：</p><ul><li><p><code>socket</code> 使用 <code>socket_create()</code> 创建的套接字资源</p></li><li><p><code>address</code></p><p>如果套接字是 <code>AF_INET</code> 族，那么 <code>address</code> 必须是一个四点法的 IP 地址，例如 <code>127.0.0.1</code>、<code>0.0.0.0</code></p><p>如果套接字是 <code>AF_UNIX</code> 族，那么 <code>address</code> 是 Unix 套接字一部分（例如 <code>/tmp/my.sock</code> ）</p></li><li><p><code>port</code> （可选）</p><p>该参数仅用于使用 <code>AF_INET</code> 族时，指定当前套接字监听的端口号</p></li></ul><p>返回值：</p><p>绑定成功返回 <code>true</code>，失败时则返回 <code>false</code>，同 <code>socket_create</code> ，在绑定失败时可以调用 <code>socket_last_error()</code> 获取错误码，错误码可以通过 <code>socket_strerror(int $err_no)</code> 转换为文字的错误说明。</p><h4 id="socket-listen"><a href="#socket-listen" class="headerlink" title="socket_listen"></a>socket_listen</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">socket_listen</span>(resource <span class="variable">$socket</span> [, <span class="keyword">int</span> <span class="variable">$backlog</span>]): <span class="keyword">bool</span></span><br></pre></td></tr></tbody></table></figure><p>在使用 <code>socket_create()</code> 创建套接字并使用 <code>socket_bind()</code> 将其绑定到名称之后，可能会告诉它侦听套接字上的传入连接。该函数仅适用于 <code>SOCK_STREAM</code> 或 <code>SOCK_SEQPACKET</code> 类型的套接字。</p><p>参数：</p><ul><li><code>socket</code> 使用 <code>socket_create()</code> 创建的套接字资源</li><li><code>backlog</code> 最大数量的积压传入连接将排队等待处理，如果连接请求到达时队列已满，则客户端可能会收到指示为 <code>ECONNREFUSED</code> 的错误。或者，如果底层协议支持重传，则可能会忽略该请求，以便重试可能会成功。</li></ul><p>返回值：</p><p>绑定成功返回 <code>true</code>，失败时则返回 <code>false</code>，可以调用 <code>socket_last_error()</code> 获取错误码，错误码可以通过 <code>socket_strerror(int $err_no)</code> 转换为文字的错误说明。</p><h4 id="socket-accept"><a href="#socket-accept" class="headerlink" title="socket_accept"></a>socket_accept</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">socket_accept</span>(resource <span class="variable">$socket</span>): resource|<span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>阻塞并监听套接字创建的连接，用户接收客户端请求</p><p>参数：</p><ul><li><code>socket</code> 使用 <code>socket_create()</code> 创建的套接字资源</li></ul><p>返回值：</p><p>成功时返回一个新的套接字资源，错误时返回 <code>false</code>，可以调用 <code>socket_last_error()</code> 获取错误码，错误码可以通过 <code>socket_strerror(int $err_no)</code> 转换为文字的错误说明。</p><h4 id="socket-connect"><a href="#socket-connect" class="headerlink" title="socket_connect"></a>socket_connect</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">socket_connect</span>(resource <span class="variable">$socket</span>, <span class="keyword">string</span> <span class="variable">$address</span> [, <span class="keyword">int</span> <span class="variable">$port</span> = <span class="literal">null</span>]): <span class="keyword">bool</span></span><br></pre></td></tr></tbody></table></figure><p>使用套接字实例发起到 <code>address</code> 的连接</p><p>参数：</p><ul><li><p><code>socket</code> 该参数必须是由 <code>socket_create()</code> 创建的 <code>socket</code> 实例</p></li><li><p><code>address</code></p><p>如果套接字是 <code>AF_INET</code> 族，那么 <code>address</code> 必须是一个四点法的 IP 地址，例如 <code>127.0.0.1</code> 如果支持 IPv6 并且套接字是 <code>AF_INET6</code>，那么 <code>address</code> 也可以是一个有效的 IPv6 地址（例如 <code>::1</code>）</p><p>如果套接字是 <code>AF_UNIX</code> 族，那么 <code>address</code> 是 Unix 套接字一部分（例如 <code>/tmp/my.sock</code> ）</p></li></ul><p>返回值：</p><p>成功时返回 <code>true</code>， 或者在失败时返回 <code>false</code></p><h4 id="socket-write"><a href="#socket-write" class="headerlink" title="socket_write"></a>socket_write</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">socket_write</span>(resource <span class="variable">$socket</span>, <span class="keyword">string</span> <span class="variable">$data</span> [, <span class="keyword">int</span> <span class="variable">$length</span> = <span class="literal">null</span>]): <span class="keyword">int</span>|<span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>传输数据至指定套接字</p><p>参数：</p><ul><li><p><code>socket</code> 使用 <code>socket_create()</code> 或 <code>socket_accept()</code> 创建的套接字资源</p></li><li><p><code>data</code> 要发送的内容</p></li><li><p><code>length</code> （可选）</p><p>可以指定发送套接字的替代字节长度。如果这个长度大于实际发送内容的长度，它将被静默地截断为实际发送内容的长度。</p></li></ul><p>返回值：</p><p>成功时返回成功发送的字节数，或者在失败时返回 <code>false</code>，可以调用 <code>socket_last_error()</code> 与 <code>socket_strerror(int $err_no)</code> 获取具体错误信息</p><h4 id="socket-read"><a href="#socket-read" class="headerlink" title="socket_read"></a>socket_read</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">socket_read</span>(resource <span class="variable">$socket</span>, <span class="keyword">int</span> <span class="variable">$length</span>, <span class="keyword">int</span> <span class="variable">$mode</span> = PHP_BINARY_READ): <span class="keyword">string</span>|<span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>从套接字资源内读取数据</p><p>参数：</p><ul><li><p><code>socket</code> 使用 <code>socket_create()</code> 或 <code>socket_accept()</code> 创建的套接字资源（服务端为 <code>socket_accept()</code> 客户端为 <code>socket_create()</code>）</p></li><li><p><code>length</code> 指定最大能够读取的字节数。否则您可以使用 <code>\r</code>、<code>\n</code>、<code>\0</code> 结束读取（根据 <code>mode</code> 参数设置）</p></li><li><p><code>mode</code> （可选）</p><p><code>PHP_BINARY_READ</code> （默认）- 使用系统的 <code>recv()</code> 函数。二进制安全地读取数据。</p><p><code>PHP_NORMAL_READ</code> - 读取到 <code>\n</code>、<code>\r</code> 时停止。</p></li></ul><p>返回值：</p><p><code>socket_read()</code> 返回一个字符串，表示接收到的数据。如果发生了错误（包括远程主机关闭了连接），则返回 <code>false</code>，可以调用 <code>socket_last_error()</code> 与 <code>socket_strerror(int $err_no)</code> 获取具体错误信息</p><h4 id="socket-close"><a href="#socket-close" class="headerlink" title="socket_close"></a>socket_close</h4><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">socket_close</span>(resource <span class="variable">$socket</span>): <span class="keyword">void</span></span><br></pre></td></tr></tbody></table></figure><p>关闭并销毁一个套接字资源</p><p>参数：</p><ul><li><code>socket</code> 使用 <code>socket_create()</code> 或 <code>socket_accept()</code> 创建的套接字资源</li></ul><p>返回值：</p><p>无</p></div><div class="top-div"><ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#socket%E4%BB%8B%E7%BB%8D"><span class="top-box-text">socket介绍</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#php%E5%AE%9E%E7%8E%B0socket"><span class="top-box-text">php实现socket</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C"><span class="top-box-text">快速体验</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A"><span class="top-box-text">语法解释</span></a></li></ol></li></ol></div></div></div><div class="next-post"><a class="purple-link" href="/rsync/"><h3 class="post-title"> 下一篇：rsync 配置和使用</h3></a></div></div><div id="gitalk-container"></div><footer><div class="site-footer"><div class="social-container"><a href="https://github.com/f-dong" target="_blank"><i class="fab fa-github"></i></a></div> Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a> | <a class="icp" href="https://beian.miit.gov.cn" target="_blank">豫ICP备2022011962号</a> | <a class="icp" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41010402002848" target="_blank">豫公网安备41010402002848号</a></div></footer></div><script src="/js/jquery.min.js"></script><script src="/js/jquery.fancybox.min.js"></script><script src="/js/main.js"></script><script src="/js/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"eaa8ec37487184406145",clientSecret:"77f9955d0267c1331df7cc706cfa385d2befb9c6",repo:"blog",owner:"f-dong",admin:["f-dong"],id:location.pathname.slice(1,location.pathname.lastIndexOf("/")).substring(0,49),distractionFreeMode:!1,createIssueManually:!0});gitalk.render("gitalk-container")</script><script src="/js/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"eaa8ec37487184406145",clientSecret:"77f9955d0267c1331df7cc706cfa385d2befb9c6",repo:"blog",owner:"f-dong",admin:["f-dong"],id:location.pathname.slice(1,location.pathname.lastIndexOf("/")).substring(0,49),distractionFreeMode:!1});gitalk.render("gitalk-container")</script><script>
        // 代码语言
        $(function () {
          $('code').each(function () {
            var code_language = $(this).attr('class');

            if (!code_language) {
              return true;
            }
            var lang_name = code_language.replace("line-numbers", "").trim().replace("highlight", "").trim().replace("language-", "").trim();

            $(this).attr('data-content-after', lang_name || 'CODE');
          });
          $('.highlight').each(function () {
            var code_language = $(this).attr('class');

            if (!code_language) {
              return true;
            }
            var lang_name = code_language.replace("highlight", "").trim();

            $(this).attr('data-content-after', lang_name || 'CODE');
          });
        });

        let mainNavLinks = document.querySelectorAll(".top-box a");

        window.addEventListener("scroll", event => {
          let fromTop = window.scrollY + 100;

          mainNavLinks.forEach((link, index) => {
            let section = document.getElementById(decodeURI(link.hash).substring(1));
            let nextSection = null
            if (mainNavLinks[index + 1]) {
              nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
            }
            if (section.offsetTop <= fromTop) {
              if (nextSection) {
                if (nextSection.offsetTop > fromTop) {
                  link.classList.add("current");
                } else {
                  link.classList.remove("current");
                }
              } else {
                link.classList.add("current");
              }
            } else {
              link.classList.remove("current");
            }
          });
        });
    </script></body></html>