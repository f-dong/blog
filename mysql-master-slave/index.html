<!DOCTYPE html><html lang="zh-CN"><head><script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script><meta charset="utf-8"><title>MySQL 主从复制实现原理</title><meta name="keywords" content="mysql,mysql 备份恢复,数据库,数据库数据恢复,mysql主从复制,数据恢复,运维,数据复制,主从复制,高可用,故障切换,读写分离"><meta name="description" content="通过主从复制功能，创建一个或者多个从库，可以有效提高数据库的可用性、可扩展性。当主库发生故障时，可以快速将某一个从库切换为主库使用而不影响正常业务；随着系统中业务访问量的增大，可以把读请求的负载分布到各个从库上。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/style/main.css"><link rel="stylesheet" href="/style/jquery.fancybox.min.css"><link rel="stylesheet" href="/style/gitalk.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-2GM6102E19"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2GM6102E19")</script><link rel="alternate" href="/atom.xml" title="codeover" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="codeover" type="application/rss+xml"></head><body><div id="app" class="main"><div class="site-header-container"><div class="site-header"><div class="left"> <a href="https://www.codeover.cn"><img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px"></a><a href="https://www.codeover.cn"><h1 class="site-title">codeover</h1></a></div><div class="right"><i class="icon menu-switch icon-menu-outline"></i></div></div></div><div class="menu-container" style="height:0;opacity:0"><nav class="menu-list"> <a href="/" class="menu purple-link">首页</a> <a href="/tags/" class="menu purple-link">标签</a> <a href="/categories/" class="menu purple-link">分类</a> <a href="/archives/" class="menu purple-link">归档</a> <a href="/about/" class="menu purple-link">关于</a></nav></div><div class="content-container"><div class="post-detail"><h2 class="post-title">MySQL 主从复制实现原理</h2><div class="post-info post-detail-info"><span><i class="icon icon-calendar-outline"></i> 2022-05-12</span><span><i class="icon icon-pricetags-outline"></i> <a href="/tags/linux/">linux ，</a> <a href="/tags/mysql/">mysql</a></span></div><div class="post-content-wrapper"><div class="post-content"><p>通过主从复制功能，创建一个或者多个从库，可以有效提高数据库的可用性、可扩展性。当主库发生故障时，可以快速将某一个从库切换为主库使用而不影响正常业务；随着系统中业务访问量的增大，可以把读请求的负载分布到各个从库上，写请求则转发给主库，形成读写分离的架构，来提供更好的读扩展和请求的负载均衡。</p><h2 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h2><ol><li>读写分离<br>在日常的开发过程中，某些业务操作数据库时需要锁表或锁行，这会影响进程的正常运行，使用主从复制后，让主库负责增删改，从库负责读，这样即使主库出现了锁表的场景，也不会影响业务的正常运行。</li><li>架构扩展<br>随着系统中业务访问量的激增，如果是单机部署 mysql ，就会出现性能瓶颈，有了主从复制，增加多个从库，将请求的负载分发到多个从库，可有效提升业务承载能力。</li><li>故障切换<br>因为数据是实时备份的，当主库因某种意外原因突然不可用时，将某一个从库切换为主库使用(主从切换)，可以快速的完成故障切换，从而减少对业务的影响。</li><li>高可用（HA）</li></ol><h2 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h2><ol><li>主节点将改变内容记录到二进制日志(mysql binlog)中，这些记录叫做二进制日志事件(binary log events)</li><li>从库启动 <em>I/O线程</em> ，与主库建立客户端连接，并请求从指定指定日志文件(binlog)的指定位置(或从最开始的日志)之后的日志内容。</li><li>主库启动 <em>binlog dump进程</em> ，读取主库的 <code>binary log event</code> 并发送给从库的 <em>I/O进程</em> 。</li><li>从库的 <em>I/O线程</em> 获取到主库发送的日志内容(binlog)后，将收到的日志更新到本机的中继日志(relay-log)中，</li><li>从库的 <em>SQL线程</em> 检测到 <code>relay-log</code> 新增了内容后，将 <code>relay-log</code> 中的内容解析为 SQL 语句执行。</li></ol> <a target="_blank" rel="noopener" href="https://cdn.codeover.cn/img/627e68e70947543129af718d.jpg-imageFop" data-fancybox="lightbox" data-caption="核心步骤图解"><img src="https://cdn.codeover.cn/img/627e68e70947543129af718d.jpg-imageFop" alt="核心步骤图解" style="zoom:50%"></a><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>在项目在刚起步时，一般单体应用就足够了，很少会有一开始就高主从架构的，费时间、费钱而且徒增了复杂度。当业务扩展，请求膨胀，主库几乎无法承担压力了，就会开始考虑开始部署主从复制。</p><h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><p>一主一从或一主多从是最常见的主从架构，实施起来简单并且有效。一主多从模型适合少量写，大量读的业务场景，可以将读请求分发至各个从节点，可有效地减轻主库的<em>读压力</em></p> <a target="_blank" rel="noopener" href="https://cdn.codeover.cn/img/627e689a0947543129ae4824.jpg-imageFop" data-fancybox="lightbox" data-caption="一主多从图解"><img src="https://cdn.codeover.cn/img/627e689a0947543129ae4824.jpg-imageFop" alt="一主多从图解" style="zoom:50%"></a><h3 id="多主一从"><a href="#多主一从" class="headerlink" title="多主一从"></a>多主一从</h3><p>多主一从可以将多个主库备份到同一从数上，一般情况下不会使用此模型。此模型需要 mysql 版本大于等于 5.7</p> <a target="_blank" rel="noopener" href="https://cdn.codeover.cn/img/627e6c800947543129bccefb.jpg-imageFop" data-fancybox="lightbox" data-caption="多主一从图解"><img src="https://cdn.codeover.cn/img/627e6c800947543129bccefb.jpg-imageFop" alt="多主一从图解" style="zoom:50%"></a><h3 id="级联复制"><a href="#级联复制" class="headerlink" title="级联复制"></a>级联复制</h3><p>主节点如果有太多的从节点，就会损耗相当一部分性能用于复制数据（replication），级联复制就是使部分从节点同时担任主节点的复制（replication）工作，这样不仅仅可以缓解主节点的压力，并且对数据一致性没有影响。</p> <a target="_blank" rel="noopener" href="https://cdn.codeover.cn/img/627e73d80947543129d8c746.jpg-imageFop" data-fancybox="lightbox" data-caption="级联复制图解"><img src="https://cdn.codeover.cn/img/627e73d80947543129d8c746.jpg-imageFop" alt="级联复制图解" style="zoom:50%"></a><h3 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h3><p>主主复制就是两个主库相互复制。可以对任何一个数据库进行写操作，任何一个数据库的数据发生变化都会同步到另一台服务器上，这种模式任何一个库挂了都不会对业务造成致命影响。<br>但是主主复制实际上并不可靠，两个主库发生冲突的可能性是极大的，加入复制停止了，系统仍在向两个主库中写入数据，也就是会出现一部分数据在库A，一部分数据在库B，要恢复这部分数据的难度会非常大。</p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>mysql 主从复制默认是异步模式，mysql 增删改操作会全部记录在 <code>binlog</code> 中，当从库连接到主库时，会主动的从主库获取最新的 <code>binlog</code>。</p><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>异步模式（mysql async-mode）下，主库不会主动地向从库推送，而是等待从库的 <em>I/O线程</em> 连接建立。主库在执行完自己的的事务之后直接将结果写入 <code>binlog</code> ，不会关心从库是否已接收并处理，这种模式下处理请求与主从复制是完全异步的，如果从库在执行复制时挂掉，可能会出现主从数据不一致的现象。</p> <a target="_blank" rel="noopener" href="https://cdn.codeover.cn/img/627fbdce09475431298a8b81.jpg-imageFop" data-fancybox="lightbox" data-caption="异步复制流程"><img src="https://cdn.codeover.cn/img/627fbdce09475431298a8b81.jpg-imageFop" alt="异步复制流程" style="zoom:36%"></a><h3 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h3><p>在同步复制模式下，主库执行完一个事务，必须等待所有从库全部执行完复制，才会给客户端返回成功，也因此同步模式下，性能会大打折扣。</p><p>指的注意的是，在此模式下，主库会直接提交事务，而不是等待所有从库复制完才提交，此模式只是延迟了对客户端的返回，所以在极端情况下此模式依旧会出现主从数据不一致的情况。</p> <a target="_blank" rel="noopener" href="https://cdn.codeover.cn/img/627fc33109475431299f6bf0.jpg-imageFop" data-fancybox="lightbox" data-caption="同步复制流程"><img src="https://cdn.codeover.cn/img/627fc33109475431299f6bf0.jpg-imageFop" alt="同步复制流程" style="zoom:36%"></a><h3 id="半同步模式"><a href="#半同步模式" class="headerlink" title="半同步模式"></a>半同步模式</h3><p>半同步模式（mysql semi-sync）介于异步复制与同步复制之间，与同步模式一样，在主库执行完事务后不会立即提交，而是至少一个从库收到并写入到中继日志（relay-log）后才返回成功信息给客户端（只保证记录到中继日志中，并不能保证从库能正确的将此事务更新到 DB 中），如果超过了默认的时间人没有从库写入成功，就会切换到异步模式提交。相对于异步复制，一定程度上保证了数据能准确同步到从库，同时相对于同步复制节省了部分性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>mysql 主从复制是 mysql 高可用、高性能的基础，有了这个基础，mysql 的部署会变得灵活并且具有多样性、可扩振性，从而可以根据不同的业务场景做出灵活的调整。<br>在实际应用中，设计之初就应根据具体需求确立复制模型与复制方式，并定期检查数据一致性，以免主库发生意外却无法及时切换从库使用。</p></div><div class="top-div"><ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94"><span class="top-box-text">主要用途</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4"><span class="top-box-text">核心步骤</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%A8%A1%E5%9E%8B"><span class="top-box-text">模型</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E"><span class="top-box-text">一主多从</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%A4%9A%E4%B8%BB%E4%B8%80%E4%BB%8E"><span class="top-box-text">多主一从</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%BA%A7%E8%81%94%E5%A4%8D%E5%88%B6"><span class="top-box-text">级联复制</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="top-box-text">主主复制</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%A8%A1%E5%BC%8F"><span class="top-box-text">模式</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="top-box-text">异步复制</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="top-box-text">同步复制</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="top-box-text">半同步模式</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%80%BB%E7%BB%93"><span class="top-box-text">总结</span></a></li></ol></div></div></div><div class="next-post"><a class="purple-link" href="/mysql-backup-recovery/"><h3 class="post-title"> 下一篇：MySQL 备份恢复策略</h3></a></div></div><div id="gitalk-container"></div><footer><div class="site-footer"><div class="social-container"><a href="https://github.com/f-dong" target="_blank"><i class="icon icon-github"></i></a></div> Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a> | <a class="icp" href="https://beian.miit.gov.cn" target="_blank">豫ICP备2022011962号</a> | <a class="icp" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41010402002848" target="_blank">豫公网安备41010402002848号</a></div></footer></div><script src="/js/jquery.min.js"></script><script src="/js/jquery.fancybox.min.js"></script><script id="hexo-configurations">window.theme_config={image:{lazyload_enable:!1}},window.is_post=!0</script><script src="/js/main.js"></script><script src="/js/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"eaa8ec37487184406145",clientSecret:"77f9955d0267c1331df7cc706cfa385d2befb9c6",repo:"blog",owner:"f-dong",admin:["f-dong"],id:location.pathname.slice(1,location.pathname.lastIndexOf("/")).substring(0,49),distractionFreeMode:!1,createIssueManually:!0});gitalk.render("gitalk-container")</script></body></html>