<!DOCTYPE html><html lang="zh-CN"><head><script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script><meta charset="utf-8"><title>Go 语言的基本数据类型</title><meta name="keywords" content="golang,basic types,基本类型,数据类型,Go语言"><meta name="description" content="Go语言内置布尔、字符串、整数、字节、Unicode、浮点、复数等基本类型。变量申明时没有显式赋初始值，则默认是“零”。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/style/main.css"><link rel="stylesheet" href="/style/jquery.fancybox.min.css"><link rel="stylesheet" href="/style/gitalk.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-2GM6102E19"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2GM6102E19")</script><link rel="alternate" href="/atom.xml" title="codeover" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="codeover" type="application/rss+xml"></head><body><div id="app" class="main"><div class="site-header-container"><div class="site-header"><div class="left"> <a href="https://www.codeover.cn"><img class="avatar" src="/images/avatar.png" alt="" width="32px" height="32px"></a><a href="https://www.codeover.cn"><h1 class="site-title">codeover</h1></a></div><div class="right"><i class="icon menu-switch icon-menu-outline"></i></div></div></div><div class="menu-container" style="height:0;opacity:0"><nav class="menu-list"> <a href="/" class="menu purple-link">首页</a> <a href="/tags/" class="menu purple-link">标签</a> <a href="/categories/" class="menu purple-link">分类</a> <a href="/archives/" class="menu purple-link">归档</a> <a href="/about/" class="menu purple-link">关于</a></nav></div><div class="content-container"><div class="post-detail"><h2 class="post-title">Go 语言的基本数据类型</h2><div class="post-info post-detail-info"><span><i class="icon icon-calendar-outline"></i> 2022-09-27</span><span><i class="icon icon-pricetags-outline"></i> <a href="/tags/Go/">Go</a></span></div><div class="post-content-wrapper"><div class="post-content"><p>数据类型的出现是为了用大数据需要存储不同的数据，编程的时候的时间才需要申请大的内存，可以利用内存。</p><p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p><h2 id="布尔型-bool"><a href="#布尔型-bool" class="headerlink" title="布尔型 bool"></a>布尔型 bool</h2><p>Go 中以 <code>bool</code> 类型声明布尔型数据，布尔型的值只能是常量 <code>true</code> 或 <code>false</code></p><ul><li>布尔型的变量默认值为 <code>false</code></li><li>布尔型无法参与数值运算，也无法与其他类型互转</li></ul><h2 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h2><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><p>Go 的整型主要分为有符号和无符号两大类。按长度可以分为 <code>int8</code>、<code>int16</code>、<code>int32</code> 与 <code>int64</code>，对应的无符号整型分别为 <code>uint8</code>、<code>uint16</code>、<code>uint32</code> 与 <code>uint64</code>。</p><table><thead><tr><th align="center">类型</th><th align="center">符号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>uint8</code></td><td align="center">无符号</td><td align="left">8位整型 (0 到 255)</td></tr><tr><td align="center"><code>uint16</code></td><td align="center">无符号</td><td align="left">6位整型 (0 到 65535)</td></tr><tr><td align="center"><code>uint32</code></td><td align="center">无符号</td><td align="left">32位整型 (0 到 4294967295)</td></tr><tr><td align="center"><code>uint64</code></td><td align="center">无符号</td><td align="left">64位整型 (0 到 18446744073709551615)</td></tr><tr><td align="center"><code>int8</code></td><td align="center">有符号</td><td align="left">8位整型 (-128 到 127)</td></tr><tr><td align="center"><code>int16</code></td><td align="center">有符号</td><td align="left">16位整型 (-32768 到 32767)</td></tr><tr><td align="center"><code>int32</code></td><td align="center">有符号</td><td align="left">32位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="center"><code>int64</code></td><td align="center">有符号</td><td align="left">64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr><tr><td align="center"><code>uint</code></td><td align="center">无符号</td><td align="left"><strong>特殊</strong> 在 32 位操作系统就是 <code>uint32</code>，64 位操作系统就是 <code>uint64</code>，但不能将 <code>uint</code> 赋值给 <code>uint32</code> 或 <code>uint64</code></td></tr><tr><td align="center"><code>int</code></td><td align="center">有符号</td><td align="left"><strong>特殊</strong> 在 32 位操作系统就是 <code>int32</code>，64 位操作系统就是 <code>int64</code>，但不能将其赋值给 <code>int32</code> 或 <code>int64</code> 变量</td></tr><tr><td align="center"><code>uintptr</code></td><td align="center">无符号</td><td align="left">无符号整型，用于存放一个指针</td></tr></tbody></table><h4 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h4><p>在 Go 1.13 版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 <code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 <code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p><p>而且还允许我们用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p><p>我们可以借助 fmt 函数来将一个整数以不同进制形式展示。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="comment">// 十进制</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%d \n"</span>, a)  <span class="comment">// 10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%b \n"</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 八进制  以0开头</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int</span> = <span class="number">077</span></span><br><span class="line">	fmt.Printf(<span class="string">"%o \n"</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 十六进制  以0x开头</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="type">int</span> = <span class="number">0xff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%x \n"</span>, c)  <span class="comment">// ff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%X \n"</span>, c)  <span class="comment">// FF</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Go 语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循 <code>IEEE 754</code> 标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串就是移除固定长度的字符串拼接起来的字符序列，Go 的字符串是由单个字节链接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本</p><h3 id="单引号与双引号的区别"><a href="#单引号与双引号的区别" class="headerlink" title="单引号与双引号的区别"></a>单引号与双引号的区别</h3><p>与 PHP 不同，在 Go 中，需要使用双引号来表示字符串（其实质是一个byte类型的数组），单引号则表示 rune 类型（UTF-8字符）</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">"中国"</span>) <span class="comment">// 中国</span></span><br><span class="line">fmt.Println(<span class="string">'中'</span>) <span class="comment">// 20013 (UTF-8编码值)</span></span><br></pre></td></tr></tbody></table></figure><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>如果需要在字符串内添加特殊符号，就需要使用转义字符，Go 语言中常见的转义字符如下：</p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td><code>\r</code></td><td>回车符（返回行首）</td></tr><tr><td><code>\n</code></td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\'</code></td><td>单引号</td></tr><tr><td><code>\"</code></td><td>双引号</td></tr><tr><td><code>\\</code></td><td>反斜杠</td></tr></tbody></table><h3 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h3><p>在 Go 中，使用双引号定义字符串是最常见的方式，被称为字符串字面量<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="footnote--top">[1]<content class="footnote--pop-ups">字符串字面量（stringliteral）是指双引号引住的一系列字符，双引号中可以没有字符，可以只有一个字符，也可以有很多个字符。</content></span></a></sup>，这种定义方式不能跨行，如果需要在代码中定义一个多行字符串时，就可以使用 ` 反引号，代码如下</p><p>反引号 `，是键盘上 ESC 键下边的键，两个反引号间的字符串将被原样赋值到 str 变量中。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">str := <span class="string">`</span></span><br><span class="line"><span class="string">第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第四行</span></span><br><span class="line"><span class="string">不会转义字符，会原样输出，例如这样\r\n</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></tbody></table></figure><p>代码运行结果：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一行</span><br><span class="line">第二行</span><br><span class="line"></span><br><span class="line">第四行</span><br><span class="line">不会转义字符，会原样输出，例如这样\r\n</span><br></pre></td></tr></tbody></table></figure><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a>数组 (Array)</h2><p>Go 语言提供了数组类型的数据结构，Go 中的数组是顺序索引，固定数据类型且固定数据个数的序列，数组通过索引（位置）来读取或修改，索引从 0 开始，第一个元素的索引为 0，第二个索引为 1，第三个索引为 2，以此类推。数组的下边取值范围是从 0 开始，到长度减 1</p><p>数组一旦定义后，大小（长度）不能改变</p><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>Go 语言声明数组需要指定长度以及数据类型，其语法格式如下：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="type">string</span>{<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"李老六"</span>, <span class="string">"王二狗"</span>}</span><br><span class="line">fmt.Println(arr) <span class="comment">// [张三 李四 王五 李老六 王二狗]</span></span><br></pre></td></tr></tbody></table></figure><p>数组初始化中的 <code>{}</code> 中的元素个数不能大于 <code>[]</code> 中的数字</p><p>数组的其他创建方式：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">string</span> <span class="comment">// 等价于 var arr = [5]string{}</span></span><br><span class="line">fmt.Println(arr) <span class="comment">// [    ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>]<span class="type">string</span>{<span class="string">"张三"</span>, <span class="string">"李老六"</span>, <span class="string">"王二狗"</span>}</span><br><span class="line">fmt.Println(b) <span class="comment">// [张三 李四 王二狗]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">5</span>]<span class="type">int</span>{<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'李'</span>}</span><br><span class="line">fmt.Println(c) <span class="comment">// [65 66 67 68 26446]</span></span><br><span class="line"></span><br><span class="line">d := [...]<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>} <span class="comment">// 根据元素的个数，设置数组的大小</span></span><br><span class="line">fmt.Println(d) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line"></span><br><span class="line">e := [<span class="number">5</span>]<span class="type">int</span>{<span class="number">4</span>: <span class="number">100</span>, <span class="number">3</span>: <span class="number">200</span>} <span class="comment">// 指定键，没有设置的键默认为对应类型的空值</span></span><br><span class="line">fmt.Println(e) <span class="comment">// [0 0 0 200 100]</span></span><br><span class="line"></span><br><span class="line">f := [...]<span class="type">int</span>{<span class="number">0</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">2</span>, <span class="number">10</span>: <span class="number">100</span>}</span><br><span class="line">fmt.Println(f) <span class="comment">// [1 0 0 0 2 0 0 0 0 0 100]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h3><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    a := [...]<span class="type">float64</span>{<span class="number">67.7</span>, <span class="number">98.6</span>, <span class="number">26</span>, <span class="number">33</span>}</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ {</span><br><span class="line">        fmt.Printf(<span class="string">"key: %d----val: %.2f\n"</span>, i, a[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// key: 0----val: 67.70</span></span><br><span class="line"><span class="comment">// key: 1----val: 98.60</span></span><br><span class="line"><span class="comment">// key: 2----val: 26.00</span></span><br><span class="line"><span class="comment">// key: 3----val: 33.00</span></span><br></pre></td></tr></tbody></table></figure><p>使用 range 遍历数组：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    a := [...]<span class="type">float64</span>{<span class="number">67.7</span>, <span class="number">98.6</span>, <span class="number">26</span>, <span class="number">33</span>}</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a {</span><br><span class="line">        fmt.Printf(<span class="string">"key: %d----val: %.2f\n"</span>, i, a[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// key: 0----val: 67.70</span></span><br><span class="line"><span class="comment">// key: 1----val: 98.60</span></span><br><span class="line"><span class="comment">// key: 2----val: 26.00</span></span><br><span class="line"><span class="comment">// key: 3----val: 33.00</span></span><br></pre></td></tr></tbody></table></figure><h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片 (Slice)"></a>切片 (Slice)</h2><p>Go 语言切片是对数组的抽象。</p><p>Go 数组的长度不可改变，在一些特定的需求下，这样的设定就不太适用，因此，Go 提供了一种灵活的内置类型：切片(Slice)，与数组相比，切片的长度是不固定的，可以随意追加元素，在追加时使切片容量增大。</p><p>切片是一种方便、灵活且强大的类型，切片本身没有任何数据，他们只是对现有数组的引用。切片与数组相比，不需要指定长度，从概念上来说切片像一个结构体，这个结构体包含了三个元素：</p><ol><li>指针：指向数组中切片指定的开始位置。</li><li>长度：即切片的长度。</li><li>最大长度，也就是切片开始位置到数组的最后位置的长度。</li></ol><h3 id="切片的语法"><a href="#切片的语法" class="headerlink" title="切片的语法"></a>切片的语法</h3><h3 id="定义切片："><a href="#定义切片：" class="headerlink" title="定义切片："></a>定义切片：</h3><p>可以通过声明一个未指定长度的数组的方式</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></tbody></table></figure><p>切片不需要说明长度，或者可使用 <code>make()</code> 函数来创建切片，<code>make()</code> 是 Go 的内置函数：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">// 也可以简写成</span></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">slice[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">slice[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">slice[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">fmt.Println(slice) <span class="comment">// [1 2 3 4 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line">s := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">fmt.Println(s) <span class="comment">// [1 2 3]</span></span><br></pre></td></tr></tbody></table></figure><p>可以将数组中的元素创建为一个切片，切片内容为 <code>startIndex</code> 到 <code>endIndex-1</code>（不包含 <code>endIndex</code>）</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">s := arr[startIndex, endIndex]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">s1 := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(s) <span class="comment">// [2 3 4]</span></span><br></pre></td></tr></tbody></table></figure><h4 id="向切片中追加数据"><a href="#向切片中追加数据" class="headerlink" title="向切片中追加数据"></a>向切片中追加数据</h4><p>如果想向切片中增加元素则需要使用 <code>append()</code> 函数，<code>append()</code> 是 Go 的内置函数，如果超出初始化时的最大容量，Go 会将原切片内容（底层数组）拷贝，并重新创建原数组两倍长度的新数组，将拷贝的内容填充至新的底层数组</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="集合-Map"><a href="#集合-Map" class="headerlink" title="集合 (Map)"></a>集合 (Map)</h2><p>map 是 Go 中的内置类型，他将一个值与一个键关联起来，可以使用相应的键检索值。map 是一种无需的键值对的集合。map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。map 是一种集合，所以我们可以向迭代数组或切片一样迭代他，不过，map 是无序的，我们无法决定他返回的顺序，这是因为 map 底层是使用 hash 表来实现的，map 是引用类型变量</p><p>使用 map 过程中需注意的点：</p><ul><li>map 是无序的，每次打印出来的 map 都可能会不一致，它不能通过 index 获取，而必须通过 key 获取</li><li>map 的长度是不固定的，也就是和切片一样，也是一种引用类型</li><li>内置的 <code>len()</code> 函数同样适用于 map，返回 map 拥有的所有 key 的数量</li><li>map 的 key 可以是所有可比较类型，如布尔型、整型、浮点型、复杂性、字符串……</li><li>键不能重复，如果重复，那么新的 value 会覆盖原来的，程序不会报错</li></ul><h3 id="map-的使用"><a href="#map-的使用" class="headerlink" title="map 的使用"></a>map 的使用</h3><h4 id="创建-map"><a href="#创建-map" class="headerlink" title="创建 map"></a>创建 map</h4><p>可以使用 Go 内置的函数 <code>make()</code> 来定义 map：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量，map 的默认值是 nil</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 make 函数</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------</span></span><br><span class="line">rating := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>{<span class="string">"PHP"</span>: <span class="number">5</span>, <span class="string">"Go"</span>: <span class="number">4.5</span>, <span class="string">"Java"</span>: <span class="number">3</span>, <span class="string">"Python"</span>: <span class="number">2</span>}</span><br></pre></td></tr></tbody></table></figure><p>如果不初始化 map，那么就会创建一个 nil map，nil map 不能用来存放键值对。</p><h4 id="读取-map"><a href="#读取-map" class="headerlink" title="读取 map"></a>读取 map</h4><p>我们可以通过 key 获取 map 中对应的 value 值，语法为：</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[key]</span><br></pre></td></tr></tbody></table></figure><p>但是当 key 不存在时，我们会得到该 value 值类型的默认值，比如 string 类型得到空字符串，int 类型得到 0，但是程序并不会报错。所以我们可以使用 ok-idiom 获取值，以便确认 key 是否在 map 中存在</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br><span class="line"><span class="keyword">if</span> ok {</span><br><span class="line">    fmt.Println(<span class="string">"对应的数值是："</span>, value)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    fmt.Println(<span class="string">"key 不存在，获取的是零值"</span>, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go 语言是静态类型语言，要求赋值、运算必须类型一致。没有隐式类型转换，只有在需要时强制类型转换，且只能在两个支持相互转换的类型才可以转换。</p><p>强制转换类型的基本语法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Type(Value)</span><br></pre></td></tr></tbody></table></figure><p>其中，Type 表示要转换的类型，Value 为要转换的变量、复杂运算和函数返回值等等。</p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="type">int8</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">int16</span></span><br><span class="line">num2 = <span class="type">int16</span>(num1)</span><br><span class="line">fmt.Printf(<span class="string">"%T,%d,%T,%d"</span>, num1, num1, num2, num2) <span class="comment">// int8,10,int16,10</span></span><br><span class="line"></span><br><span class="line">float1 := <span class="number">4.83</span></span><br><span class="line"><span class="keyword">var</span> num3 <span class="type">int</span></span><br><span class="line">num3 = <span class="type">int</span>(float1)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%T,%f,%T,%d"</span>, float1, float1, num3, num3) <span class="comment">// float64,4.830000,int,4</span></span><br></pre></td></tr></tbody></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0;margin-left:40px"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px;margin-left:-40px">1.</span><span style="display:inline-block;vertical-align:top;margin-left:10px">字符串字面量（stringliteral）是指双引号引住的一系列字符，双引号中可以没有字符，可以只有一个字符，也可以有很多个字符。 <a href="#fnref:1">↩</a></span></li></ol></div></div></div><div class="top-div"><ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B-bool"><span class="top-box-text">布尔型 bool</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%95%B0%E5%80%BC%E5%9E%8B"><span class="top-box-text">数值型</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B"><span class="top-box-text">整数型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="top-box-text">浮点型</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="top-box-text">字符串</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">单引号与双引号的区别</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="top-box-text">转义字符</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="top-box-text">定义多行字符串</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%95%B0%E7%BB%84-Array"><span class="top-box-text">数组 (Array)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84"><span class="top-box-text">声明数组</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8"><span class="top-box-text">数组使用</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%88%87%E7%89%87-Slice"><span class="top-box-text">切片 (Slice)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="top-box-text">切片的语法</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%AE%9A%E4%B9%89%E5%88%87%E7%89%87%EF%BC%9A"><span class="top-box-text">定义切片：</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9B%86%E5%90%88-Map"><span class="top-box-text">集合 (Map)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#map-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="top-box-text">map 的使用</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="top-box-text">类型转换</span></a></li></ol></div></div></div><div class="next-post"><a class="purple-link" href="/proxy-settings/"><h3 class="post-title"> 下一篇：各常用包管理器配置科学上网代理</h3></a></div></div><div id="gitalk-container"></div><footer><div class="site-footer"><div class="social-container"><a href="https://github.com/f-dong" target="_blank"><i class="icon icon-github"></i></a></div> Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a> | <a class="icp" href="https://beian.miit.gov.cn" target="_blank">豫ICP备2022011962号</a> | <a class="icp" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41010402002848" target="_blank">豫公网安备41010402002848号</a></div></footer></div><script src="/js/jquery.min.js"></script><script src="/js/jquery.fancybox.min.js"></script><script>window.is_post=!0</script><script src="/js/main.js"></script><script src="/js/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"eaa8ec37487184406145",clientSecret:"77f9955d0267c1331df7cc706cfa385d2befb9c6",repo:"blog",owner:"f-dong",admin:["f-dong"],id:location.pathname.slice(1,location.pathname.lastIndexOf("/")).substring(0,49),distractionFreeMode:!1,createIssueManually:!0});gitalk.render("gitalk-container")</script></body></html>